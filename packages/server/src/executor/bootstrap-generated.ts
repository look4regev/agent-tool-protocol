/**
 * AUTO-GENERATED - DO NOT EDIT
 * Generated by scripts/generate-bootstrap.ts
 *
 * This file contains the bootstrap code injected into the isolated-vm sandbox

/**
 * Bootstrap code for isolated-vm context
 * Creates the globalThis.atp object with all runtime APIs
 *
 * Each method is a wrapper that calls the corresponding isolated-vm Reference
 * The References must be set using context.global.set() before evaluating this code
 *
 * Required References (11 total):
 * - __atp_approval_request
 * - __atp_cache_delete
 * - __atp_cache_get
 * - __atp_cache_has
 * - __atp_cache_set
 * - __atp_embedding_embed
 * - __atp_embedding_search
 * - __atp_llm_call
 * - __atp_llm_classify
 * - __atp_llm_extract
 * - __atp_progress_report
 */
export const BOOTSTRAP_CODE = `
		globalThis.atp = {
				approval: {
					request: async (message, approvalContext) => {
						return await __atp_approval_request.apply(undefined, [message, approvalContext], { arguments: { copy: true }, result: { promise: true } });
					}
				},
				llm: {
					call: async (options) => {
						return await __atp_llm_call.apply(undefined, [options], { arguments: { copy: true }, result: { promise: true } });
					},
					extract: async (options) => {
						return await __atp_llm_extract.apply(undefined, [options], { arguments: { copy: true }, result: { promise: true } });
					},
					classify: async (options) => {
						return await __atp_llm_classify.apply(undefined, [options], { arguments: { copy: true }, result: { promise: true } });
					}
				},
				cache: {
					get: async (key) => {
						return await __atp_cache_get.apply(undefined, [key], { arguments: { copy: true }, result: { promise: true } });
					},
					set: async (key, value, ttl) => {
						return await __atp_cache_set.apply(undefined, [key, value, ttl], { arguments: { copy: true }, result: { promise: true } });
					},
					delete: async (key) => {
						return await __atp_cache_delete.apply(undefined, [key], { arguments: { copy: true }, result: { promise: true } });
					},
					has: async (key) => {
						return await __atp_cache_has.apply(undefined, [key], { arguments: { copy: true }, result: { promise: true } });
					}
				},
				embedding: {
					embed: async (text, options) => {
						return await __atp_embedding_embed.apply(undefined, [text, options], { arguments: { copy: true }, result: { promise: true } });
					},
					search: async (query, options) => {
						return await __atp_embedding_search.apply(undefined, [query, options], { arguments: { copy: true }, result: { promise: true } });
					}
				},
				progress: {
					report: (message, fraction) => {
						__atp_progress_report.applyIgnored(undefined, [message, fraction], { arguments: { copy: true } });
					}
				}
				};
`;

/**
 * List of all isolated-vm Reference names that must be injected
 */
export const REQUIRED_REFERENCES = [
	'__atp_approval_request',
	'__atp_cache_delete',
	'__atp_cache_get',
	'__atp_cache_has',
	'__atp_cache_set',
	'__atp_embedding_embed',
	'__atp_embedding_search',
	'__atp_llm_call',
	'__atp_llm_classify',
	'__atp_llm_extract',
	'__atp_progress_report',
];
